{"./":{"url":"./","title":"Introduction","keywords":"","body":"Kamigo 簡介 Kamigo 是一個基於 Rails 的 Chatbot MVC Framework。 Kamigo 讓你開發 Chatbot 就跟開發網站一樣容易，甚至可以同時開發網站以及 Chatbot 介面，共用 Controller 和 Model，只需要針對 Chatbot 實作 View。 Kamigo 提供了重要的 generator，讓你開發聊天機器人時可以快的跟飛一樣。 以下將說明如何使用 Kamigo 來製作 Todo 的教學文件。 建立新的 rails 專案 將以下指令全部複製，直接貼到 bash 執行即可。 # 建立新專案 rails new kamigo_demo # 進入專案 cd kamigo_demo # 安裝套件 bundle add kamigo bundle add dotenv-rails # 新增 resource controller rails g scaffold todo name desc rails db:create rails db:migrate 設定首頁 在 config/routes.rb 當中加入首頁設定： root to: \"todos#index\" 安裝 js 套件 在 app/assets/javascripts/application.js 當中加入一行程式碼： //= require kamiliff 設定聊天機器人 Webhook URL 本文假設你已經有一個自己的聊天機器人，請將以下網址填入 LINE Bot 的 Webhook URL 欄位中： https://你的網域/line 第一次開發 LINE Bot 的人可以服用此帖 Webhook URL 設定 QA。 設定聊天機器人環境變數 請在專案根目錄下新增一個 .env 檔並且填入以下內容： LINE_CHANNEL_SECRET=這裡填入你的 LINE_CHANNEL_SECRET LINE_CHANNEL_TOKEN=這裡填入你的 LINE_CHANNEL_ACCESS_TOKEN LIFF_COMPACT=這裡填入你的 COMPACT_LIFF_URL LIFF_TALL=這裡填入你的 TALL_LIFF_URL LIFF_FULL=這裡填入你的 FULL_LIFF_URL LINE_CHANNEL_SECRET 可以在 Messaging API 後台的 Basic settings 分頁中找到。 LINE_CHANNEL_ACCESS_TOKEN 可以在 Messaging API 後台的 Messaging API 分頁中找到。 COMPACT_LIFF_URL、TALL_LIFF_URL 和 FULL_LIFF_URL 需要到 LINE 後台的 LIFF 分頁新增後，即可獲得一組 LIFF URL。 Kamigo 預設的 LIFF Size 為 Compact，你也可以只新增 Compact LIFF URL。 詳細的 LIFF 設定說明可以服用此帖 LIFF 設定 QA。 至此串接完成。 實際使用 Kamigo 預設使用基本的語意理解模型，會將使用者輸入視為在瀏覽器網址上輸入文字，並且以 LINE Flex Message 來顯示對應的結果。 開啟 LINE 和聊天機器人說 /，就能看到首頁的樣子。 使用 kamigo 製作的聊天機器人 kamigo demo 健身紀錄機器人: Muscle-Man 守護寵物機器人 詳細的說明文件 Kamigo 架構概觀 Route 的使用說明 Controller 的使用說明 View 的使用說明 Form 的使用說明 Kamigo 相關設定與 QA 計畫 提供多種語意理解模型串接 網站使用者與聊天機器人使用者綁定 支援 Telegram 支援 Facebook Messenger License The gem is available as open source under the terms of the MIT License. "},"01_intro.html":{"url":"01_intro.html","title":"Kamigo 架構概觀","keywords":"","body":"Kamigo 架構概觀 設計理念 Kamigo 是基於 Rails 的 Chatbot MVC Framework，竭盡所能的將聊天機器人的開發與網站開發做對應，並且盡可能的使用 Rails 既有的功能來增加彈性。 在聊天機器人開發當中的「語意理解」是對應到網站開發當中的路由（Route）。 「對話管理」對應到 Controller 以及 Model。 而「語言生成」則是對應到 view。 使用 Kamigo，你可以同時開發 Chatbot 以及 Web，而且共用 Controller 以及 Model。 架構概觀 Kamigo 實作了接受 LINE Webhook 的 Controller 以及對應的 Route。 controller: https://github.com/etrex/Kamigo/blob/master/app/controllers/line_controller.rb routes: https://github.com/etrex/Kamigo/blob/master/config/routes.rb 以上的程式碼使得 Kamigo 在接收到來自 Webhook 的訊息後，會將訊息用語意理解的方式轉換為（Intent）以及關鍵字（Entity），並且生成一個新的 Request 再發送給對應的 Controller Action，取得 Response 後，再使用 Reply API 將 Response 訊息回傳給用戶。 webhook 設定 從 routes.rb 當中可以看到這一行： post 'line', to: 'line#entry' 表示網站會接受 POST 到 /line 的 Request，並且交給 line_controller 當中的 entry 方法來處理。 這表示你應該在你的 LINE Bot 設定 Webhook Url 為 https://你的網域/line。 rails generator 在安裝 Kamigo 後，使用 rails g scaffold 可以生成 Kamigo 魔改後的 controller 以及 view。 以下簡單說明各項負責的功能。 routes Kamigo 沒有修改 rails routes 的實作。 line_controller 會讀取 LINE 訊息當中的文字訊息，並且嘗試理解文字訊息當中的意圖（intent）以及關鍵字（entity），也就是語意理解的部分， 目前僅實作了一個最基本的語意理解模型，直接假設用戶輸入的文字是網址來做解析，之後會支援各大語意理解平台的串接。 擷取出意圖以及關鍵字之後，會嘗試找到此意圖所對應的 controller action，並且將關鍵字作為 params 傳入此 action。 簡而言之，語意理解就像是在做 routes 的工作。 目前 Kamigo 支援在 routes 撰寫一些簡單的語意理解規則，比方說，你可以在你的專案當中的 routes.rb 寫入以下程式碼： get \"目錄\", to: 'home#menu' 當用戶在對 LINE Bot 發話時輸入「目錄」文字訊息時，就可以將 Request 交給 home_controller 當中的 menu 方法來處理。 詳細說明請參考 route Render Format 當用戶在對 LINE Bot 發話時輸入「目錄」時，實際上，Kamigo 會生成一個 GET https://你的網域/目錄.line 的 Request 網址當中的 .line 是在指定 render format，當一個 Request 的 Format 為 line 的時候，render engine 會去嘗試尋找 views 資料夾當中副檔名為 .line 的檔案。 你可以在 controller 當中透過 params[:format] 取得當下 Request 的 Format 為何。 Controller 在 controller 你可以在 params 收到一些來自 Kamigo 的參數，用來做身分驗證或取得用戶所發出的關鍵字等。 詳細說明請參考 controller View 在 view 當中，直接輸出 LINE Message API 所需要的 json 即可。 使用 Kamiflex 可以讓你輕鬆打造出 flex message。 詳細說明請參考 view Form 目前 Kamigo 僅提供 LIFF 作為表單填寫的解決方案，日後有可能會加入對話式表單的填寫。 Kamigo 使用 Kamiliff 來製作 LIFF，你可以在 controller 就取得用戶身分的參數。 詳細說明請參考 form "},"02_route.html":{"url":"02_route.html","title":"Route 的使用說明","keywords":"","body":"Route 的使用說明 以下將說明 Kamigo 如何解讀用戶輸入，並且找出對應的 Controller Action。 語意理解模型 Kamigo 目前使用了最簡單的解析器去解讀用戶輸入，其格式如下： {{http_method}} {{path}} {{json}} 舉例來說，若用戶輸入如下： GET /todos 即視為用戶對 /todos 發出 GET Request。 POST /todos {\"todo\":{\"name\":\"kamigo\"}} 即視為用戶對 /todos 發出 POST Reques，並且傳遞一個 json 作為 body。 預設值 其中，如果 http_method 是 GET 的話，可省略，path 開頭的 / 也可以省略，所以當用戶的輸入如下： GET /menu 或 /menu 或 menu 即視為用戶對 /menu 發出 GET Request。 之後 Kamigo 的計畫包含實作支援各大語意理解平台的 Adapter。 routes 以下示範在 routes.rb 適用於聊天機器人的各種寫法。 可以寫中文 get \"目錄\", to: 'home#menu' 如此即可接受用戶輸入「目錄」時，將 Request 轉給 home_controller 的 menu 方法來處理。 可以使用變數 get \"學 *keyword *message\", to: 'keywords#learn' 如此即可接受用戶輸入「學 A B」時，將 Request 轉給 keywords_controller 的 learn 方法來處理，你可以在 controller 當中寫 params[:keyword] 取得用戶輸入的 A，寫 params[:message] 取得用戶輸入的 B。 變數可加括號，變數可省略 get '(*location)天氣', to: 'weathers#show' 如此即可接受用戶輸入「台北天氣」時，將 Request 轉給 weathers_controller 的 show 方法來處理，你可以在 controller 當中寫 params[:location] 取得用戶輸入的「台北」。 get '(*location)天氣', to: 'weathers#show' 如此即可接受用戶輸入「台北天氣」時，將 Request 轉給 weathers_controller 的 show 方法來處理，你可以在 controller 當中寫 params[:location] 取得用戶輸入的「台北」。 get '(*location)天氣(*other)', to: 'weathers#show' 如此即可接受用戶輸入「台北天氣如何」。 "},"03_controller.html":{"url":"03_controller.html","title":"Controller 的使用說明","keywords":"","body":"Controller 的使用說明 在 controller 當中你可以取得幾個重要的 params: platform_type platform_type 表示目前的 Request 是來自於哪一個通訊軟體。 Kamigo 目前僅支援 LINE，因此 platform_type 的值會是 \"line\"。 你可以使用以下程式碼取得 platform_type: params[:platform_type] source_type source_type 表示目前的 Request 是來自於那一種對話框，其可能的值為 \"user\"、\"room\"、\"group\"。 你可以使用以下程式碼取得 source_type: params[:source_type] source_group_id source_group_id 表示目前 Request 是來自於哪一個對話框。 若 source_type 的值為 \"user\"，則 source_group_id 會與 LINE 提供的 userId 相等。 若 source_type 的值為 \"room\" 或 \"group\"，則 source_group_id 的值會等於 LINE 提供的 roomId 或 groupId。 你可以使用以下程式碼取得 source_group_id: params[:source_group_id] source_user_id source_user_id 表示目前 Request 是來自於哪一個使用者。 source_user_id 會與 LINE 提供的 userId 相等。 在無法取得 userId 的某些情形下，source_user_id 的值將會與 source_group_id 相等。 你可以使用以下程式碼取得 source_user_id: params[:source_user_id] 身分驗證 你可以假設 source_group_id 以及 source_user_id 是秘密資訊，以 source_group_id 和 source_user_id 來識別對話框以及用戶。 "},"04_view.html":{"url":"04_view.html","title":"View 的使用說明","keywords":"","body":"View 的使用說明 在 view 當中，你可以根據不同的通訊平台，去製作對應的回覆內容。 Kamigo 會根據目前的平台，選擇對應的 render format，以 LINE 來說就會是 .line。 由於 Kamigo 目前只支援 LINE 通訊平台，因此目前只有 .line 可以使用。 舉例來說，如果你在 config/routes.rb 寫入以下程式： get \"目錄\", to: 'home#index' 而且你有 app/controllers/home_controller 內容如下： class HomeController 即表示你應該要在 app/views/home/index.line 或者 app/views/home/index.line.erb 或者 app/views/home/index.line.jbuilder 來寫你的回覆訊息。 比方說，你可以在 app/views/home/index.line 輸入以下訊息： { \"type\": \"text\", \"text\": \"Hello, world\" } 或者你可以在 app/views/home/index.line.erb 輸入以下訊息： 或者你可以在 app/views/home/index.line.jbuilder 輸入以下訊息： json.type \"text\" json.text \"Hello, world\" 最終都會產生出一樣的 json，也就是 LINE Messaging API 所要求的格式： { \"type\": \"text\", \"text\": \"Hello, world\" } 使用 Flex Message LINE Messaging API 提供了一種訊息格式，稱為 Flex Message。 你可以使用 Kamiflex 來快速生成 Flex Message。 目前在 view 當中使用 Kamiflex 的方法是使用 erb，比方說在 app/views/home/index.line.erb 輸入以下程式碼： 更多的 Kamiflex 使用說明 使用 LIFF 更換 LIFF Size 使用 liff_path 方法時，新增指定參數 liff_size： "},"05_kamiflex.html":{"url":"05_kamiflex.html","title":"Kamiflex 的使用說明","keywords":"","body":"概觀 Kamiflex讓你以程式碼的方式取代Flex Messages JSON，達到方便、簡潔、易維護易擴展的目的。Kamiflex目前僅支援Line平台上的Flex Message，在Kamiflex之下Line Flex Message的架構如下： 以kamigo預設的index.line.erb為例，其轉換為Json的關係圖如下： 上圖數字代表意義為： Flex Message Meta 核心元件 容器元件 基礎組件 以Kamiflex編寫的程式碼會是以下： Kamiflex.build(self) do #Flex Message Header bubble do #核心元件 body do #核心元件屬性 horizontal_box do #容器元件 text \"🍔\", flex: 0, action: message_action(\"/\") #基礎組件 text \"Todos\" #基礎組件 text \"🆕\", align: \"end\", action: uri_action(new_todo_path)#基礎組件 end separator #基礎組件 if @todos.present? vertical_box margin: \"lg\" do #容器元件 horizontal_box @todos, margin: \"lg\" do |todo| #容器元件 text todo.name, action: message_action(\"/todos/#{todo.id}\") #基礎組件 text \"❌\", align: \"end\", action: message_action(\"DELETE /todos/#{todo.id}\") #基礎組件 end end else text \"no contents yet\", margin: \"lg\" #基礎組件 end end end end 在部分的元件後會加入一些屬性，達到修飾的效果。例如text \"no contents yet\", margin: \"lg\"，這是一個文字基礎元件，text \"no contents yet\"為主題，後方的margin: \"lg\"則用來修改該元件的屬性，部份元件的屬性修改則是放置於Block中，請依據文件規範編寫，若不額外指定則會使用預設的屬性。 關於屬性內容詳細說明請參照flex message object "},"kamiflex/flex_message_meta.html":{"url":"kamiflex/flex_message_meta.html","title":"Flex Message Meta","keywords":"","body":"Flex Message Meta Flex Message Meta是每一個Flex Message一定會包含的部分，其Json為 { type: \"flex\", altText: \"this is a flex message\", contents: {...} } 對應的Kamiflex程式碼為 Kamiflex.build(self) do ... end kamiflex會將該程式碼轉換為Json，{...}為block，可以在其中放入核心元件(如bubble、carousel)。 屬性 alt_text 說明 此屬性的修改放在Block中，預設文字為this is a flex message。 使用範例 { \"type\": \"flex\", \"altText\": \"test alt text\", \"contents\": { \"type\": \"bubble\", \"body\": { \"type\": \"box\", \"layout\": \"vertical\", \"contents\": [ { \"type\": \"text\", \"text\": \"Hello, World!\" } ] } } } 運行結果 "},"kamiflex/core.html":{"url":"kamiflex/core.html","title":"核心元件","keywords":"","body":"核心元件 核心元件需被寫在Flex Message Meta的block之中。 bubble 說明 此元件為Flex Message最基礎之核心元件。 詳細說明請參考以下連結： LINE Flex Message 關於 Bubble 的說明文件 LINE Flex Message 關於 Bubble 的 API Reference 相關參數 請參考官方文件中的bubble 使用範例 Ruby寫法： Kamiflex.build(self) do bubble size: \"nano\",direction: \"ltr\" do body do text \"Hello, World!\" end end end 對應的Json： { \"type\": \"flex\", \"altText\": \"this is a flex message\", \"contents\": { \"type\": \"bubble\", \"body\": { \"type\": \"box\", \"layout\": \"vertical\", \"contents\": [ { \"type\": \"text\", \"text\": \"Hello, World!\" } ] }, \"size\": \"nano\", \"direction\": \"ltr\" } } bubbles 說明 此元件需使用在carousel之中，達成橫向多筆Flex Message，若不使用此核心元件，亦可使用Ruby原生的#each搭配bubble達到相同功能。 相關參數 與bubble相同，請參考官方文件中的bubble 使用範例 使用bubbles的Ruby寫法： @strings = [\"string1\", \"string2\", \"string3\"] Kamiflex.build(self) do carousel do bubbles @strings, size: \"nano\", direction: \"ltr\" do |string| body do text string end end end end 不使用bubbles的Ruby寫法： Kamiflex.build(self) do carousel do @strings.each do |string| bubble size: \"nano\", direction: \"ltr\" do body do text string end end end end end 對應的Json： { \"type\": \"flex\", \"altText\": \"this is a flex message\", \"contents\": { \"type\": \"carousel\", \"contents\": [ { \"type\": \"bubble\", \"body\": { \"type\": \"box\", \"layout\": \"vertical\", \"contents\": [ { \"type\": \"text\", \"text\": \"string1\" } ] }, \"size\": \"nano\", \"direction\": \"ltr\" }, { \"type\": \"bubble\", \"body\": { \"type\": \"box\", \"layout\": \"vertical\", \"contents\": [ { \"type\": \"text\", \"text\": \"string2\" } ] }, \"size\": \"nano\", \"direction\": \"ltr\" }, { \"type\": \"bubble\", \"body\": { \"type\": \"box\", \"layout\": \"vertical\", \"contents\": [ { \"type\": \"text\", \"text\": \"string3\" } ] }, \"size\": \"nano\", \"direction\": \"ltr\" } ] } } carousel 說明 此元件可以達成橫向多筆的Flex Message，但在其之中還需要加上bubble元件。 LINE Flex Message 關於 Carousel 的說明文件 LINE Flex Message 關於 Carousel 的 API Reference 相關參數 最多僅能12個bubble 使用範例 使用bubbles的Ruby寫法： @strings = [\"string1\", \"string2\", \"string3\"] Kamiflex.build(self) do carousel do bubbles @strings, size: \"nano\", direction: \"ltr\" do |string| body do text string end end end end 不使用bubbles的Ruby寫法： Kamiflex.build(self) do carousel do @strings.each do |string| bubble size: \"nano\", direction: \"ltr\" do body do text string end end end end end 對應的Json： { \"type\": \"flex\", \"altText\": \"this is a flex message\", \"contents\": { \"type\": \"carousel\", \"contents\": [ { \"type\": \"bubble\", \"body\": { \"type\": \"box\", \"layout\": \"vertical\", \"contents\": [ { \"type\": \"text\", \"text\": \"string1\" } ] }, \"size\": \"nano\", \"direction\": \"ltr\" }, { \"type\": \"bubble\", \"body\": { \"type\": \"box\", \"layout\": \"vertical\", \"contents\": [ { \"type\": \"text\", \"text\": \"string2\" } ] }, \"size\": \"nano\", \"direction\": \"ltr\" }, { \"type\": \"bubble\", \"body\": { \"type\": \"box\", \"layout\": \"vertical\", \"contents\": [ { \"type\": \"text\", \"text\": \"string3\" } ] }, \"size\": \"nano\", \"direction\": \"ltr\" } ] } } 屬性 核心元件屬性需放置在bubble或是bubbles的block之中，並且各個屬性應確保其Json同層而不存在上下層關聯。 header 說明 呈現在Flex Message最頂部，一般用來放置標題使用 相關參數 \bKamflex會為header自動創立一個容器元件box，關於容器元件box參數請參考官方文件中的box 此處無法直接使用header參數，若想使用header參數請搭配styles 使用範例 Ruby的寫法： Kamiflex.build(self) do bubble do header layout: \"vertical\", borderWidth: \"light\", backgroundColor: \"#c3c3c3\" do text \"hello, wrold!\" end end end 對應的json： { \"type\": \"flex\", \"altText\": \"this is a flex message\", \"contents\": { \"type\": \"bubble\", \"header\": { \"type\": \"box\", \"layout\": \"vertical\", \"contents\": [ { \"type\": \"text\", \"text\": \"hello, wrold!\" } ], \"borderWidth\": \"light\", \"backgroundColor\": \"#c3c3c3\" } } } hero 說明 呈現在Flex Message header之下，body之上，一般用來放置圖片，由於不需要搭配block。後方不需再加入{...}或是do...end。 相關參數 kamiflex預設hero的type為image元件，因此需搭配image元件參數使用 此處無法直接使用hero參數，若想使用hero參數請搭配styles hero的type除了image元件外，也可以選擇為box元件 使用範例 Ruby的寫法： Kamiflex.build(self) do bubble do hero \"https://scdn.line-apps.com/n/channel_devcenter/img/fx/01_1_cafe.png\", size: :full, aspectRatio: \"20:13\" end end 對應的json: { \"type\": \"flex\", \"altText\": \"this is a flex message\", \"contents\": { \"type\": \"bubble\", \"hero\": { \"type\": \"image\", \"url\": \"https://scdn.line-apps.com/n/channel_devcenter/img/fx/01_1_cafe.png\", \"size\": \"full\", \"aspectRatio\": \"20:13\" } } } body 說明 呈現在Flex Message中間的位置，一般用於表達內文。 參數 \bKamflex會為body自動創立一個容器元件box，關於容器元件box參數請參考官方文件中的box 此處無法直接使用body參數，若想使用body參數請搭配styles 使用範例 Ruby寫法： Kamiflex.build(self) do bubble do body layout: \"vertical\", borderWidth: \"light\", backgroundColor: \"#c3c3c3\" do text \"hello, wrold!\" end end end 對應的json： { \"type\": \"flex\", \"altText\": \"this is a flex message\", \"contents\": { \"type\": \"bubble\", \"body\": { \"type\": \"box\", \"layout\": \"vertical\", \"contents\": [ { \"type\": \"text\", \"text\": \"hello, wrold!\" } ], \"borderWidth\": \"light\", \"backgroundColor\": \"#c3c3c3\" } } } footer 說明 呈現在Flex Message最底部的位置，一般用於放置按鈕。 參數 \bKamflex會為footer自動創立一個容器元件box，關於容器元件box參數請參考官方文件中的box 此處無法直接使用footer參數，若想使用body參數請搭配styles 使用範例 Ruby寫法： Kamiflex.build(self) do bubble do footer layout: \"vertical\", borderWidth: \"light\", backgroundColor: \"#c3c3c3\" do text \"hello, wrold!\" end end end 對應的json： { \"type\": \"flex\", \"altText\": \"this is a flex message\", \"contents\": { \"type\": \"bubble\", \"footer\": { \"type\": \"box\", \"layout\": \"vertical\", \"contents\": [ { \"type\": \"text\", \"text\": \"hello, wrold!\" } ], \"borderWidth\": \"light\", \"backgroundColor\": \"#c3c3c3\" } } } styles 說明 主要功能為更改核心元件屬性的style。 相關參數 請參考官方文件中的block style 使用範例 Ruby寫法： Kamiflex.build(self) do bubble size: \"mega\" do header do text \"Kamiflex\" end hero \"https://stickershop.line-scdn.net/stickershop/v1/product/1500785/LINEStorePC/main.png;compress=true\" body do text \"\b用kamiflex就是這麼簡單\",wrap: true end footer do message_button \"同意\", \"不只好用還好潮！真的讚！\" end styles ({ header: { \"backgroundColor\": \"#ffffff\", \"separator\": true, \"separatorColor\": \"#c2c2c2\", }, hero: { \"separator\": true, \"separatorColor\": \"#c2c2c2\", }, body: { \"backgroundColor\": \"#ffffff\", \"separator\": true, \"separatorColor\": \"#c2c2c2\", }, footer: { \"backgroundColor\": \"#ffffff\", \"separator\": true, \"separatorColor\": \"#c2c2c2\", } }) end end 對應的json： { \"type\": \"flex\", \"altText\": \"this is a flex message\", \"contents\": { \"type\": \"bubble\", \"header\": { \"type\": \"box\", \"layout\": \"vertical\", \"contents\": [ { \"type\": \"text\", \"text\": \"Kamiflex\" } ] }, \"hero\": { \"type\": \"image\", \"url\": \"https://stickershop.line-scdn.net/stickershop/v1/product/1500785/LINEStorePC/main.png;compress=true\" }, \"body\": { \"type\": \"box\", \"layout\": \"vertical\", \"contents\": [ { \"type\": \"text\", \"text\": \"\\b用kamiflex就是這麼簡單\", \"wrap\": true } ] }, \"footer\": { \"type\": \"box\", \"layout\": \"vertical\", \"contents\": [ { \"type\": \"button\", \"action\": { \"type\": \"message\", \"label\": \"同意\", \"text\": \"不只好用還好潮！真的讚！\" } } ] }, \"styles\": { \"header\": { \"backgroundColor\": \"#ffffff\", \"separator\": true, \"separatorColor\": \"#c2c2c2\" }, \"hero\": { \"separator\": true, \"separatorColor\": \"#c2c2c2\" }, \"body\": { \"backgroundColor\": \"#ffffff\", \"separator\": true, \"separatorColor\": \"#c2c2c2\" }, \"footer\": { \"backgroundColor\": \"#ffffff\", \"separator\": true, \"separatorColor\": \"#c2c2c2\" } }, \"size\": \"mega\" } } "},"kamiflex/container.html":{"url":"kamiflex/container.html","title":"容器元件","keywords":"","body":"容器元件 容器元件需被寫在核心元件或是核心元件屬性的block之中。 box horizontal_box vertical_box baseline_box 說明 使用範例icon separator spacer filler "},"kamiflex/basic_element.html":{"url":"kamiflex/basic_element.html","title":"基礎組件","keywords":"","body":"基礎組件 基礎組件需被包含在容器元件中或是部分的已含有容器元件的核心元件屬性(如:header、body、footer)。 text 說明 使用範例 image 說明 使用範例 button message_button postback_button postback_text_button 說明 使用範例 "},"06_form.html":{"url":"06_form.html","title":"Form 的使用說明","keywords":"","body":"Form 的使用說明 Kamigo 使用 Kamiliff 來製作 LIFF 形式的表單。 LIFF 是可以在 LINE 開啟網頁，並且可以讓你獲得目前使用者相關資訊，以及幫使用者發訊息的技術。 Kamiliff 讓你可以不用撰寫 js，就能夠製作表單。 "},"07_setting.html":{"url":"07_setting.html","title":"Kamigo 相關設定與 QA","keywords":"","body":"Webhook URL 設定 QA 如何設定開發環境網域？ 安裝 ngrok。 在 bash 執行 ngrok 來獲得對應 http://localhost:3000 的網域。 $ ./ngrok http 3000 將獲得的網域替換掉花刮號的部分後，填入 Webhook URL 欄位。（留意網域後是否有確實加上 /line） https://{NGROK_HTTPS_DOMAIN}/line 在 Messaging API 後台開啟 Use webhook 設定。 另外開一個 bash 執行 $ rails s。 點擊 Verify 按鈕發送一個 POST Request 確認設定是否成功。 重開 ngrok 後，Webhook URL 就失效了？ 若你重新執行 ngrok，則 ngrok 會產生新的網域，你需要變更 LINE Bot 的 Webhook URL 和 LIFF app 的 Endpoint URL 為新的網域。 完成串接流程，但 Kamigo 沒有反應？ 若 Webhook URL 和 .env 檔都設定完，Kamigo 仍沒有反應，請確認以下兩個設定： 確認你的網域是否正確。 確認 Use webhook 是否為開啟狀態。 LIFF 設定 QA 如何新增 LIFF？ 由於 LIFF v2 改善，LINE 官方在 2020/02/05 發布通知，日後新增 LIFF 需到 LINE Login 的 LIFF 分頁新增，原先在 Messaging API 新增的 LIFF 還能繼續使用。 在 LINE Login 後台新增 3 種不同 size 的 LIFF，新增完會各獲得一組 LIFF URL；若你在 Messaging API 有設定好的 LIFF，請參考下方設定修改 Endpoint URL。（留意網域後是否有確實加上 /liff_entry） Compact LIFF app name: Compact Size: Compact Endpoint URL: https://你的網域/liff_entry Tall LIFF app name: Tall Size: Tall Endpoint URL: https://你的網域/liff_entry Full LIFF app name: Full Size: Full Endpoint URL: https://你的網域/liff_entry 在 .env 檔中分別填入對應 size 的 3 個 LIFF URL。 於 Messaging API 所建立的 LIFF（v1） LIFF_COMPACT=line://app/{FOR_COMPACT_LIFF_ID} LIFF_TALL=line://app/{FOR_TALL_LIFF_ID} LIFF_FULL=line://app/{FOR_FULL_LIFF_ID} 於 LINE Login 所建立的 LIFF（v2） LIFF_COMPACT=https://liff.line.me/{FOR_COMPACT_LIFF_ID} LIFF_TALL=https://liff.line.me/{FOR_TALL_LIFF_ID} LIFF_FULL=https://liff.line.me/{FOR_FULL_LIFF_ID} "}}